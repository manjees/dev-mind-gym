# 📌 동적 프로그래밍(Dynamic Programming, DP) 개요

## 🔹 DP란 무엇인가?
**동적 프로그래밍(Dynamic Programming, DP)**은 문제를 **체계적이고 효율적으로 해결**할 수 있는 프로그래밍 기법입니다.  
특히, **"중복되는 부분 문제(Overlapping Subproblems)"**와 **"최적 부분 구조(Optimal Substructure)"**를 가진 문제에서 효과적입니다.

---

## ✅ DP의 두 가지 핵심 개념
### 1️⃣ **중복되는 부분 문제 (Overlapping Subproblems)**
- 문제를 **작은 하위 문제들로 나눌 수 있으며, 이 하위 문제들이 여러 번 반복해서 사용됨**.
- **한 번 계산한 값을 저장하여 재사용**하면 중복 계산을 줄일 수 있음.

### 2️⃣ **최적 부분 구조 (Optimal Substructure)**
- 문제의 **최적해(Optimal Solution)**가 **하위 문제들의 최적해로부터 구성될 수 있음**.
- 즉, 작은 문제들을 해결하면서 큰 문제를 최적의 방법으로 해결 가능.

## 알고리즘 유형 비교
| 알고리즘 유형 | 최적 부분 구조 | 중복되는 부분 문제 |
|-------------|------------|----------------|
| **그리디(Greedy)** | ✅ 있음 | ❌ 없음 |
| **분할 정복(Divide and Conquer)** | ✅ 있음 | ❌ 없음 (각 부분 문제가 독립적) |
| **동적 프로그래밍(DP)** | ✅ 있음 | ✅ 있음 |

> **📌 DP는 분할 정복과 유사하지만, 중복되는 부분 문제를 저장하여 최적화할 수 있다는 점에서 차별화된다.**

# 📌 DP의 강력한 이유

동적 프로그래밍(DP)은 **문제를 더 작은 문제로 나누고, 불필요한 중복 계산을 줄여 성능을 크게 향상**시킵니다.  
다음은 **피보나치 수열 계산을 예로 들어 비교**해 보겠습니다.

---

## 🔹 피보나치 수열의 알고리즘별 시간 복잡도

| 방법 | 시간 복잡도 | 특징 |
|-----|----------|------|
| **브루트 포스 (재귀, 단순 계산)** | `O(2^N)` (지수 시간) ❌ | 중복 계산이 많아 비효율적 |
| **동적 프로그래밍 (메모이제이션 사용)** | `O(N)` (선형 시간) ✅ | 중복 계산 없이 최적화됨 |

> **🚀 DP는 단순한 브루트 포스보다 훨씬 빠른 성능을 제공한다!**

---

# 🚀 동적 프로그래밍(DP) 알고리즘 구현 방법

## 📌 1. Bottom-up (Tabulation)
- 반복문을 사용하여 Base Case부터 시작하여 문제를 해결
### Bottom-up 방식의 수도 코드
```
F = 배열 크기 (n + 1)
F[0] = 0
F[1] = 1
for i from 2 to n:
    F[i] = F[i - 1] + F[i - 2]
```

---

### 📌 2. Top-down (Memoization)
- 재귀(Recursion)를 사용하고, 메모이제이션(Memoization) 기법으로 최적화
### Top-down 방식의 수도 코드
```
memo = 해시맵(HashMap)
Function F(integer i):
    if i is 0 or 1: 
        return i
    if i doesn't exist in memo:
        memo[i] = F(i - 1) + F(i - 2)
    return memo[i]
```

---

### 📌 3. Bottom-up vs. Top-down 비교
| 방식 | 주요 장점 |
|------|------------------------------------------|
| **Bottom-up (Tabulation)** | ✅ 반복문을 사용하므로 실행 속도가 빠름 (재귀의 오버헤드 없음) |
| **Top-down (Memoization)** | ✅ 구현이 더 쉽고 직관적 (재귀를 사용하면 하위 문제의 순서를 신경 쓰지 않아도 됨) |

---

# 📌 동적 프로그래밍 문제 주요 특징
- ✅ 문제에서 최적값(최대, 최소) 또는 가능한 방법의 수를 요구하는 경우
- ✅ "이전의 결정이 이후의 결정에 영향을 미치는 경우"

# Multidimensional DP

## 차원의 정의
DP 문제에서 차원(Dimensions)이란 각 상태(State)를 정의하는 데 사용되는 상태 변수(State Variables)의 개수를 의미한다.
> - 상태 변수가 많아질수록 DP 문제의 난이도는 상승한다.  - 가장 흔한 것은 1~2차원이지만, 때로는 5차원 이상의 복잡한 문제도 존재한다.

## DP 문제에서의 상태 변수 유형
### 입력 인덱스
- 배열 또는 문자열 등 입력 데이터를 특정 인덱스까지 고려할 때 사용된다.
- 예시: dp(i) → 입력 배열의 0부터 i까지 고려한 문제의 답
### 두 번째 입력 인덱스(Second Index)
- 입력 데이터를 특정 범위(start ~ end)까지 고려할 때 사용된다.
- 예시: dp(i, j) → 입력 배열의 인덱스 i부터 j까지 고려한 문제의 답
### 명시적인 수치 제약(Numerical Constraints)
- 문제에서 직접 주어진 제한 조건을 나타내는 변수
- 예시: 최대 거래 횟수(k회), 장애물 제거 횟수 등
### 상태(Status)를 나타내는 변수
- 특정 상태의 여부를 나타내는 변수
- 예시: 열쇠 보유 여부(true/false), 현재 가진 소포 개수 등
### 방문 또는 사용 여부를 나타내는 데이터(Bitmask 또는 Tuple)
- 방문 여부 등을 불변(immutable) 데이터 구조로 나타내는 변수
- 예시: 비트마스크(bitmask), 튜플(tuple)
> 주의: 메모이제이션을 위해서는 반드시 변경 불가능(immutable)한 자료구조만 사용해야 한다.

## 문제 해결 시 고려할 사항
- DP 배열 또는 함수가 명확히 무엇을 나타내는지 정의할 것
- 정확한 점화식을 구성할 것
- 차원이 늘어날수록 신중하게 접근할 필요가 있음

# 탑다운(Top-down) 알고리즘을 바텀업(Bottom-up)으로 변환하기
- 일반적으로 탑다운 알고리즘은 바텀업 알고리즘에 비해 구현이 더 쉽다. 하지만 탑다운 알고리즘을 바텀업 방식으로 변환하는 방법을 알아두는 것은 매우 유용
    - 인터뷰에서 탑다운 방식으로 문제를 해결하면, 종종 바텀업(반복문) 방식으로 다시 작성하라는 요청을 받을 수 있다.
    - 일반적으로 바텀업 방식이 탑다운 방식보다 실행시간 측면에서 더 효율적이다.

## 탑다운을 바텀업으로 변환하는 절차
1. 완성된 탑다운 구현에서 시작
2. 상태 변수를 기반으로 하는 배열 dp를 초기화한다.
- 예시: 입력이 배열 nums와 정수 k(가능한 최대 행동 횟수)라면, dp 배열은 nums.length와 k를 각각의 차원으로 가지는 2차원 배열로 초기화
- 각 원소의 값은 문제에서 원하는 값의 반대되는 값으로 초기화한다. 예를 들어 문제에서 최대값을 구한다면 배열을 음의 무한대로, 최소값을 구한다면 양의 무한대로 초기화.
3. 탑다운 알고리즘에서 사용한 베이스 케이스(Base Cases)를 설정.
- 예시: House Robber 문제에서 탑다운 방식으로 dp(0) = nums[0], dp(1) = max(nums[0], nums[1])이었다면, 바텀업에서는 배열에 다음과 같이 설정한다: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])
4. 상태 변수에 따라 반복문(for-loop)을 작성
- 여러 개의 상태 변수가 있다면 반복문을 중첩하여 작성
- 반복문은 베이스 케이스에서부터 시작하여 증가하는 형태로 설정
5. 반복문의 가장 안쪽 루프(iteration)가 특정 상태를 나타내며, 탑다운 방식에서의 함수 호출과 동일하다.
- 탑다운 함수의 로직을 그대로 반복문 안으로 옮기고, 함수 호출(dp(...))을 배열 접근(dp[...])으로 변경한다.
6. 변환 끝
- 최종적으로 배열 dp는 모든 가능한 상태에 대해 문제의 정답을 저장하게 된다.
- 원래 문제의 답을 반환할 때는 return dp(...)를 return dp[...] 형태로 변경하여 반환한다.