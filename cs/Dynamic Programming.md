# 📌 동적 프로그래밍(Dynamic Programming, DP) 개요

## 🔹 DP란 무엇인가?
**동적 프로그래밍(Dynamic Programming, DP)**은 문제를 **체계적이고 효율적으로 해결**할 수 있는 프로그래밍 기법입니다.  
특히, **"중복되는 부분 문제(Overlapping Subproblems)"**와 **"최적 부분 구조(Optimal Substructure)"**를 가진 문제에서 효과적입니다.

---

## ✅ DP의 두 가지 핵심 개념
### 1️⃣ **중복되는 부분 문제 (Overlapping Subproblems)**
- 문제를 **작은 하위 문제들로 나눌 수 있으며, 이 하위 문제들이 여러 번 반복해서 사용됨**.
- **한 번 계산한 값을 저장하여 재사용**하면 중복 계산을 줄일 수 있음.

### 2️⃣ **최적 부분 구조 (Optimal Substructure)**
- 문제의 **최적해(Optimal Solution)**가 **하위 문제들의 최적해로부터 구성될 수 있음**.
- 즉, 작은 문제들을 해결하면서 큰 문제를 최적의 방법으로 해결 가능.

## 알고리즘 유형 비교
| 알고리즘 유형 | 최적 부분 구조 | 중복되는 부분 문제 |
|-------------|------------|----------------|
| **그리디(Greedy)** | ✅ 있음 | ❌ 없음 |
| **분할 정복(Divide and Conquer)** | ✅ 있음 | ❌ 없음 (각 부분 문제가 독립적) |
| **동적 프로그래밍(DP)** | ✅ 있음 | ✅ 있음 |

> **📌 DP는 분할 정복과 유사하지만, 중복되는 부분 문제를 저장하여 최적화할 수 있다는 점에서 차별화된다.**

# 📌 DP의 강력한 이유

동적 프로그래밍(DP)은 **문제를 더 작은 문제로 나누고, 불필요한 중복 계산을 줄여 성능을 크게 향상**시킵니다.  
다음은 **피보나치 수열 계산을 예로 들어 비교**해 보겠습니다.

---

## 🔹 피보나치 수열의 알고리즘별 시간 복잡도

| 방법 | 시간 복잡도 | 특징 |
|-----|----------|------|
| **브루트 포스 (재귀, 단순 계산)** | `O(2^N)` (지수 시간) ❌ | 중복 계산이 많아 비효율적 |
| **동적 프로그래밍 (메모이제이션 사용)** | `O(N)` (선형 시간) ✅ | 중복 계산 없이 최적화됨 |

> **🚀 DP는 단순한 브루트 포스보다 훨씬 빠른 성능을 제공한다!**

---

# 🚀 동적 프로그래밍(DP) 알고리즘 구현 방법

## 📌 1. Bottom-up (Tabulation)
- 반복문을 사용하여 Base Case부터 시작하여 문제를 해결
### Bottom-up 방식의 수도 코드
```
F = 배열 크기 (n + 1)
F[0] = 0
F[1] = 1
for i from 2 to n:
    F[i] = F[i - 1] + F[i - 2]
```

---

### 📌 2. Top-down (Memoization)
- 재귀(Recursion)를 사용하고, 메모이제이션(Memoization) 기법으로 최적화
### Top-down 방식의 수도 코드
```
memo = 해시맵(HashMap)
Function F(integer i):
    if i is 0 or 1: 
        return i
    if i doesn't exist in memo:
        memo[i] = F(i - 1) + F(i - 2)
    return memo[i]
```

---

### 📌 3. Bottom-up vs. Top-down 비교
| 방식 | 주요 장점 |
|------|------------------------------------------|
| **Bottom-up (Tabulation)** | ✅ 반복문을 사용하므로 실행 속도가 빠름 (재귀의 오버헤드 없음) |
| **Top-down (Memoization)** | ✅ 구현이 더 쉽고 직관적 (재귀를 사용하면 하위 문제의 순서를 신경 쓰지 않아도 됨) |

---

# 📌 동적 프로그래밍 문제 주요 특징
- ✅ 문제에서 최적값(최대, 최소) 또는 가능한 방법의 수를 요구하는 경우
- ✅ "이전의 결정이 이후의 결정에 영향을 미치는 경우"